/*Напишите программу, которая с помощью алгоритма Дейкстры будет находить кратчайшие пути
от фиксированной вершины графа до всех остальных его вершин.
Граф задан списками смежности. Предусмотрите ввод данных из файла.
После завершения работы с динамическими структурами данных необходимо освободить занимаемую ими память.*/
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <utility>
#include <algorithm>

using namespace std;

//функция для обработки графа Алгоритмом Дейкстры
void solve(vector<vector<pair<int, int>>>& g)
{
	const int INF = 10e9;//значение бесконечности для работы алгоритма Дейкстры
	//бесконеность значит что бы не знаем можно ли дойти от одной вершины до другой 
	int s = 0;

	vector<int> d(g.size(), INF);
	d[s] = 0;
	vector<bool> used(g.size());

	for (int i = 0; i < g.size(); i++)//перебираем все вершины графа
	{//поиск вершины с наименьшим расстоянием от стартовой, из еще не посещенных 
		int v = -1;// изначально ставим -1, чтобы на первой итерации в любом случае присвоилось значение 
		for (int j = 0; j < g.size(); j++)//перебираем все вершины в графе
			if (!used[j] && (v == -1 || d[j] < d[v]))// если вершина не использовалась ранее и ( первая терация в поиске минимума или если расстояние меньше предыдущего) 
				v = j;// сохраняем

		if (d[v] == INF)// если минимальное расстояние осталось равно бесконечности, то значит идти больше никуда не можем 
			break;// выходим
		used[v] = true;// ставим что использовали вершину

		for (int j = 0; j < g[v].size(); j++)// перебираем все вершины в которые можно придти из выбранной нами 
		{
			int to = g[v][j].first;// вершина куда можем придти
			int len = g[v][j].second;// расстояние до нее
			if (d[v] + len < d[to])// если новое расстояние до нее меньше старого 
			{
				d[to] = d[v] + len;// меняем на новое 
			}
		}
	}

	for (int i = 0; i < d.size(); i++)//цикл для вывода расстояния до каждой из вершин от стартовой точки
	{
		cout << "start " << s << " to -> " << i << " = " << d[i] << endl;
	}
	cout << endl << endl;
}

//функция для считывания графа из файла
void read_file(string name, vector<vector<pair<int, int>>>& graph)
{
	ifstream ci(name);
	int size = 0;
	ci >> size;
	for (int i = 0; i < size; i++)
	{
		graph.push_back({});
		int count, vertex, dist;
		ci >> count;
		for (int j = 0; j < count; j++)
		{
			ci >> vertex >> dist;
			graph[i].push_back({ vertex, dist });
		}
	}

	ci.close();
	return;
}

int main()
{
	vector<vector<pair<int, int>>> graph;//создаем список смежности для работы с графом.
	//храним в векторе. при завершении программы память из под него автоматически освободится  

	read_file("input.txt", graph);//функция для считывания графа из файла 
	solve(graph);//функция для обработки графа
	return 0;
}